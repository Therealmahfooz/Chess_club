<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>THE CHESS CLUB</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root {
      --black-gradient: linear-gradient(145deg, #111, #000);
      --white-gradient: linear-gradient(145deg, #f9f9f9, #c0c0c0);
      --shadow-dark: rgba(0, 0, 0, 0.7);
      --shadow-light: rgba(255, 255, 255, 0.7);
      --highlight-white: 0 0 12px #ffffff, 0 0 24px #d1d1d1;
      --highlight-black: 0 0 12px #00aaff, 0 0 25px #0077cc;
      --white-piece-color: #f5f5f5;
      --white-piece-shadow: 0 0 8px rgba(0, 0, 0, 0.7);
      --black-piece-color: #111;
      --valid-move-color: rgba(0, 255, 0, 0.3);
      --capture-move-color: rgba(255, 0, 0, 0.3);
      --check-color: #ff4444;
      --checkmate-color: #ff0000;
      --win-color: #00ff00;
      --button-color: #00aaff;
    }

    body {
      background: radial-gradient(circle at center, #0a0a0a, #000);
      color: #f0f0f0;
      font-family: "Poppins", sans-serif;
      text-align: center;
      padding: 20px 10px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      font-weight: 700;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      margin-bottom: 15px;
      font-size: 3rem;
      background: linear-gradient(45deg, #fff, #00aaff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .game-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .game-mode-selection {
      margin-bottom: 0;
    }

    .mode-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .mode-btn {
      background: rgba(0, 170, 255, 0.2);
      border: 2px solid var(--button-color);
      color: #fff;
      padding: 10px 25px;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
    }

    .mode-btn:hover {
      background: rgba(0, 170, 255, 0.4);
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
    }

    .mode-btn.active {
      background: var(--button-color);
      box-shadow: 0 0 20px rgba(0, 170, 255, 0.7);
    }

    .difficulty-selector {
      display: flex;
      gap: 10px;
      align-items: center;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .difficulty-selector.hidden {
      display: none;
    }

    .difficulty-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 8px 15px;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .difficulty-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .difficulty-btn.active {
      background: rgba(0, 170, 255, 0.4);
      border-color: var(--button-color);
    }

    .sound-toggle {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sound-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .sound-toggle.active {
      background: rgba(0, 255, 0, 0.3);
      border-color: #00ff00;
    }

    .game-status {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 15px;
      min-height: 2rem;
    }

    .check-status {
      color: var(--check-color);
      text-shadow: 0 0 10px var(--check-color);
      animation: pulse 1.5s infinite;
    }

    .checkmate-status {
      color: var(--checkmate-color);
      text-shadow: 0 0 15px var(--checkmate-color);
      font-size: 2rem;
      animation: pulse 0.8s infinite;
    }

    .win-status {
      color: var(--win-color);
      text-shadow: 0 0 15px var(--win-color);
      font-size: 2.5rem;
      animation: celebrate 1s infinite;
    }

    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

    @keyframes celebrate {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .turn-indicator {
      font-size: 1.3rem;
      font-weight: 500;
      margin-bottom: 25px;
    }

    .turn-indicator span {
      font-weight: bold;
      text-shadow: 0 0 10px #fff;
    }

    .board-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      margin-bottom: 30px;
      position: relative;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      width: 90vw;
      max-width: 600px;
      aspect-ratio: 1 / 1;
      border: 6px solid #ccc;
      border-radius: 12px;
      box-shadow: 0 12px 45px rgba(255, 255, 255, 0.05),
                  inset 0 0 20px rgba(255, 255, 255, 0.05);
      position: relative;
      overflow: hidden;
      user-select: none;
      transition: all 0.5s ease;
    }

    .board.game-over {
      filter: blur(8px);
      transform: scale(0.98);
    }

    .game-over-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 40px;
      border-radius: 15px;
      border: 3px solid gold;
      box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
      z-index: 100;
      text-align: center;
      animation: popIn 0.6s ease-out;
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    .game-over-message h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      color: gold;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
    }

    .game-over-message p {
      font-size: 1.5rem;
      margin-bottom: 25px;
      color: #fff;
    }

    .restart-btn {
      background: linear-gradient(45deg, #00aaff, #0077cc);
      border: none;
      color: white;
      padding: 12px 30px;
      border-radius: 8px;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
    }

    .restart-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(0, 170, 255, 0.7);
    }

    .kill-count {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 20px;
      width: 90%;
      max-width: 800px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.2);
      margin-top: 20px;
    }

    .kill-count h3 {
      font-size: 1.4rem;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      border-bottom: 2px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 8px;
    }

    .kill-sections {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 30px;
    }

    .kill-section {
      flex: 1;
      min-width: 250px;
    }

    .kill-section h4 {
      font-size: 1.2rem;
      margin-bottom: 15px;
      color: #f0f0f0;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
    }

    .kill-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      min-height: 50px;
      align-items: center;
    }

    .kill-piece {
      font-size: 2rem;
      display: inline-block;
      transition: all 0.3s ease;
    }

    .kill-piece.new-capture {
      animation: captureFlash 0.8s ease;
    }

    @keyframes captureFlash {
      0% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.3); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    .white-kills .kill-piece {
      color: var(--white-piece-color);
      text-shadow: var(--white-piece-shadow);
    }

    .black-kills .kill-piece {
      color: var(--black-piece-color);
      text-shadow: 0 0 6px #00aaff, 0 0 15px #005577;
    }

    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      font-size: calc(2.5vw + 8px);
      cursor: pointer;
      transition: transform 0.25s ease, filter 0.25s ease;
      position: relative;
    }

    .sq-light {
      background: var(--white-gradient);
      box-shadow: inset 2px 2px 4px var(--shadow-dark),
                  inset -2px -2px 4px var(--shadow-light);
    }

    .sq-dark {
      background: var(--black-gradient);
      box-shadow: inset 2px 2px 4px var(--shadow-dark),
                  inset -2px -2px 4px rgba(255, 255, 255, 0.1);
    }

    .square:hover {
      transform: scale(1.05);
      filter: brightness(1.2);
    }

    .piece-white {
      color: var(--white-piece-color);
      text-shadow: var(--white-piece-shadow);
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
      transition: all 0.3s ease;
      position: relative;
      z-index: 1;
    }

    .piece-black {
      color: var(--black-piece-color);
      text-shadow: 0 0 6px #00aaff, 0 0 15px #005577;
      filter: drop-shadow(0 0 8px #0077cc);
      transition: all 0.3s ease;
    }

    .piece-white.selected {
      text-shadow: var(--highlight-white);
      transform: scale(1.2);
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.8));
    }

    .piece-black.selected {
      text-shadow: var(--highlight-black);
      transform: scale(1.2);
    }

    .king-in-check {
      text-shadow: 0 0 12px #ff4444, 0 0 25px #ff0000 !important;
      animation: kingPulse 1s infinite;
    }

    @keyframes kingPulse {
      0% { transform: scale(1.1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1.1); }
    }

    .valid-move::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30%;
      height: 30%;
      border-radius: 50%;
      background-color: var(--valid-move-color);
      z-index: 0;
    }

    .capture-move::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      background-color: var(--capture-move-color);
      z-index: 0;
    }

    .king-capture-move::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      background-color: rgba(255, 215, 0, 0.5);
      z-index: 0;
      animation: kingCapturePulse 0.8s infinite;
    }

    @keyframes kingCapturePulse {
      0% { background-color: rgba(255, 215, 0, 0.3); }
      50% { background-color: rgba(255, 215, 0, 0.7); }
      100% { background-color: rgba(255, 215, 0, 0.3); }
    }

    /* Promotion Modal Styles */
    .promotion-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .promotion-options {
      background: rgba(40, 40, 40, 0.95);
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 0 40px rgba(0, 170, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      text-align: center;
    }

    .promotion-title {
      font-size: 1.5rem;
      margin-bottom: 20px;
      color: #fff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .promotion-pieces {
      display: flex;
      gap: 15px;
      justify-content: center;
    }

    .promotion-piece {
      font-size: 3rem;
      width: 70px;
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: rgba(60, 60, 60, 0.7);
    }

    .promotion-piece.white {
      color: #fff;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .promotion-piece.black {
      color: #111;
      text-shadow: 0 0 8px rgba(0, 170, 255, 0.7);
      border: 2px solid rgba(0, 170, 255, 0.3);
    }

    .promotion-piece:hover {
      transform: scale(1.15);
      background: rgba(80, 80, 80, 0.9);
    }

    @media (max-width: 768px) {
      .kill-sections {
        flex-direction: column;
        align-items: center;
      }
      
      .kill-section {
        min-width: 200px;
      }
      
      .promotion-pieces {
        gap: 10px;
      }
      
      .promotion-piece {
        font-size: 2.5rem;
        width: 60px;
        height: 60px;
      }

      .game-controls {
        flex-direction: column;
      }

      h1 {
        font-size: 2.5rem;
      }
    }

    @media (max-width: 576px) {
      .square {
        font-size: calc(4vw + 6px);
      }
      
      .kill-piece {
        font-size: 1.8rem;
      }
      
      .mode-buttons {
        flex-direction: column;
        align-items: center;
      }
      
      .mode-btn {
        width: 200px;
      }

      .game-over-message {
        padding: 20px;
      }

      .game-over-message h2 {
        font-size: 2rem;
      }

      .game-over-message p {
        font-size: 1.2rem;
      }
    }
  </style>
</head>

<body>
  <div class="game-wrapper">
    <h1>THE CHESS CLUB</h1>
    
    <div class="game-controls">
      <div class="game-mode-selection">
        <div class="mode-buttons">
          <button class="mode-btn active" id="pvpMode">Player vs Player</button>
          <button class="mode-btn" id="pvcMode">Player vs Computer</button>
        </div>
      </div>
      
      <div class="difficulty-selector hidden" id="difficultySelector">
        <span>AI Level:</span>
        <button class="difficulty-btn" id="easyBtn">Easy</button>
        <button class="difficulty-btn active" id="mediumBtn">Medium</button>
        <button class="difficulty-btn" id="hardBtn">Hard</button>
      </div>
      
      <button class="sound-toggle active" id="soundToggle">
        <span>🔊</span> Sound On
      </button>
    </div>
    
    <div class="game-status" id="gameStatus"></div>
    <div class="turn-indicator">Turn: <span id="turnDisplay">White</span></div>

    <div class="board-container">
      <div class="board" id="chessboard"></div>
    </div>
    
    <div class="kill-count">
      <h3>Captured Pieces</h3>
      <div class="kill-sections">
        <div class="kill-section white-kills">
          <h4>White Captures</h4>
          <div class="kill-list" id="whiteKills"></div>
        </div>
        
        <div class="kill-section black-kills">
          <h4>Black Captures</h4>
          <div class="kill-list" id="blackKills"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Promotion Modal -->
  <div class="promotion-modal" id="promotionModal" style="display: none;">
    <div class="promotion-options">
      <div class="promotion-title" id="promotionTitle">Choose Promotion</div>
      <div class="promotion-pieces" id="promotionPieces"></div>
    </div>
  </div>

  <script>
    const board = document.getElementById("chessboard");
    const turnDisplay = document.getElementById("turnDisplay");
    const gameStatus = document.getElementById("gameStatus");
    const whiteKills = document.getElementById("whiteKills");
    const blackKills = document.getElementById("blackKills");
    const pvpModeBtn = document.getElementById("pvpMode");
    const pvcModeBtn = document.getElementById("pvcMode");
    const promotionModal = document.getElementById("promotionModal");
    const promotionTitle = document.getElementById("promotionTitle");
    const promotionPieces = document.getElementById("promotionPieces");
    const soundToggle = document.getElementById("soundToggle");
    const easyBtn = document.getElementById("easyBtn");
    const mediumBtn = document.getElementById("mediumBtn");
    const hardBtn = document.getElementById("hardBtn");
    const difficultySelector = document.getElementById("difficultySelector");
    
    let selectedSquare = null;
    let turn = "white";
    let pawnFirstMove = {};
    let gameOver = false;
    let gameMode = "pvp";
    let pendingPromotion = null;
    let soundEnabled = true;
    let difficulty = "medium";

    // Track captured pieces
    let capturedPieces = {
      white: [],
      black: []
    };

    const pieces = {
      black: { king: "♚", queen: "♛", rook: "♜", bishop: "♝", knight: "♞", pawn: "♟" },
      white: { king: "♔", queen: "♕", rook: "♖", bishop: "♗", knight: "♘", pawn: "♙" }
    };

    const pieceValues = {
      pawn: 10,
      knight: 30,
      bishop: 30,
      rook: 50,
      queen: 90,
      king: 900
    };

    const startingBoard = [
      [pieces.black.rook, pieces.black.knight, pieces.black.bishop, pieces.black.queen, pieces.black.king, pieces.black.bishop, pieces.black.knight, pieces.black.rook],
      Array(8).fill(pieces.black.pawn),
      Array(8).fill(""),
      Array(8).fill(""),
      Array(8).fill(""),
      Array(8).fill(""),
      Array(8).fill(pieces.white.pawn),
      [pieces.white.rook, pieces.white.knight, pieces.white.bishop, pieces.white.queen, pieces.white.king, pieces.white.bishop, pieces.white.knight, pieces.white.rook]
    ];

    // Sound effects using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(frequency, duration, type = 'sine', volume = 0.3) {
      if (!soundEnabled) return;
      
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.value = volume;
        
        oscillator.start();
        
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (e) {
        console.log("Sound error:", e);
      }
    }

    function playMoveSound() {
      playSound(523.25, 0.1, 'sine', 0.2);
    }

    function playCaptureSound() {
      playSound(659.25, 0.2, 'square', 0.4);
    }

    function playCheckSound() {
      playSound(783.99, 0.3, 'sawtooth', 0.5);
    }

    function playCheckmateSound() {
      playSound(523.25, 0.8, 'sine', 0.6);
      setTimeout(() => playSound(659.25, 0.8, 'sine', 0.5), 100);
      setTimeout(() => playSound(783.99, 0.8, 'sine', 0.4), 200);
    }

    function playPromotionSound() {
      playSound(523.25, 0.15, 'sine', 0.4);
      setTimeout(() => playSound(587.33, 0.15, 'sine', 0.4), 150);
      setTimeout(() => playSound(659.25, 0.15, 'sine', 0.4), 300);
      setTimeout(() => playSound(783.99, 0.3, 'sine', 0.5), 450);
    }

    function playWinSound() {
      playSound(1046.50, 0.3, 'sine', 0.6);
      setTimeout(() => playSound(1174.66, 0.3, 'sine', 0.6), 300);
      setTimeout(() => playSound(1318.51, 0.3, 'sine', 0.6), 600);
      setTimeout(() => playSound(1567.98, 0.5, 'sine', 0.7), 900);
    }

    function playSelectSound() {
      playSound(392.00, 0.1, 'sine', 0.2);
    }

    function playErrorSound() {
      playSound(220.00, 0.2, 'sawtooth', 0.3);
    }

    // Sound toggle functionality
    soundToggle.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundToggle.classList.toggle('active', soundEnabled);
      soundToggle.innerHTML = soundEnabled ? 
        '<span>🔊</span> Sound On' : 
        '<span>🔇</span> Sound Off';
      
      if (soundEnabled) {
        playSound(523.25, 0.1, 'sine', 0.2);
      }
    });

    // Difficulty selection
    function setDifficulty(level) {
      difficulty = level;
      easyBtn.classList.toggle('active', level === 'easy');
      mediumBtn.classList.toggle('active', level === 'medium');
      hardBtn.classList.toggle('active', level === 'hard');
    }

    easyBtn.addEventListener('click', () => {
      setDifficulty('easy');
      playSelectSound();
    });

    mediumBtn.addEventListener('click', () => {
      setDifficulty('medium');
      playSelectSound();
    });

    hardBtn.addEventListener('click', () => {
      setDifficulty('hard');
      playSelectSound();
    });

    // Game mode selection
    pvpModeBtn.addEventListener('click', () => {
      setGameMode('pvp');
      playSelectSound();
    });

    pvcModeBtn.addEventListener('click', () => {
      setGameMode('pvc');
      playSelectSound();
    });

    function setGameMode(mode) {
      gameMode = mode;
      
      pvpModeBtn.classList.toggle('active', mode === 'pvp');
      pvcModeBtn.classList.toggle('active', mode === 'pvc');
      
      // Show/hide difficulty selector
      difficultySelector.classList.toggle('hidden', mode === 'pvp');
      
      if (!gameOver) {
        resetGame();
      }
    }

    function showGameOverMessage(winner) {
      const boardContainer = document.querySelector('.board-container');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'game-over-message';
      messageDiv.innerHTML = `
        <h2>${winner} WINS!</h2>
        <p>${winner === 'White' ? '⚪' : '⚫'} ${winner} player has won the game!</p>
        <button class="restart-btn" onclick="resetGame()">Play Again</button>
      `;
      boardContainer.appendChild(messageDiv);
      board.classList.add('game-over');
    }

    function resetGame() {
      board.innerHTML = '';
      document.querySelector('.game-over-message')?.remove();
      board.classList.remove('game-over');
      
      selectedSquare = null;
      turn = "white";
      gameOver = false;
      pawnFirstMove = {};
      capturedPieces = { white: [], black: [] };
      pendingPromotion = null;
      
      buildBoard();
      
      updateKillDisplay();
      updateGameStatus();
      turnDisplay.textContent = "White";
      turnDisplay.style.color = "#fff";
      
      promotionModal.style.display = 'none';
    }

    // Initialize pawn first move tracking
    function initializePawnFirstMove() {
      for (let i = 0; i < 8; i++) {
        pawnFirstMove[`1-${i}`] = true;
        pawnFirstMove[`6-${i}`] = true;
      }
    }

    function getPieceColor(symbol) {
      if ("♔♕♖♗♘♙".includes(symbol)) return "white";
      if ("♚♛♜♝♞♟".includes(symbol)) return "black";
      return null;
    }

    function getPieceType(symbol) {
      if (symbol === "♙" || symbol === "♟") return "pawn";
      if (symbol === "♖" || symbol === "♜") return "rook";
      if (symbol === "♘" || symbol === "♞") return "knight";
      if (symbol === "♗" || symbol === "♝") return "bishop";
      if (symbol === "♕" || symbol === "♛") return "queen";
      if (symbol === "♔" || symbol === "♚") return "king";
      return null;
    }

    function getPieceValue(piece) {
      const pieceType = getPieceType(piece);
      return pieceValues[pieceType] || 0;
    }

    function addCapturedPiece(piece, capturingColor) {
      if (piece === pieces.white.king || piece === pieces.black.king) {
        return;
      }
      
      capturedPieces[capturingColor].push(piece);
      updateKillDisplay();
    }

    function updateKillDisplay() {
      whiteKills.innerHTML = '';
      blackKills.innerHTML = '';
      
      capturedPieces.white.forEach((piece, index) => {
        const pieceEl = document.createElement('span');
        pieceEl.textContent = piece;
        pieceEl.classList.add('kill-piece');
        
        if (index === capturedPieces.white.length - 1 && capturedPieces.white.length > 0) {
          pieceEl.classList.add('new-capture');
        }
        
        whiteKills.appendChild(pieceEl);
      });
      
      capturedPieces.black.forEach((piece, index) => {
        const pieceEl = document.createElement('span');
        pieceEl.textContent = piece;
        pieceEl.classList.add('kill-piece');
        
        if (index === capturedPieces.black.length - 1 && capturedPieces.black.length > 0) {
          pieceEl.classList.add('new-capture');
        }
        
        blackKills.appendChild(pieceEl);
      });
    }

    // Check if a pawn has reached the promotion row
    function checkPromotion(piece, row) {
      if (piece === pieces.white.pawn && row === 0) return true;
      if (piece === pieces.black.pawn && row === 7) return true;
      return false;
    }

    // Show promotion modal
    function showPromotionModal(color, square) {
      pendingPromotion = { color, square };
      
      promotionTitle.textContent = `${color.charAt(0).toUpperCase() + color.slice(1)} - Choose Promotion`;
      promotionPieces.innerHTML = '';
      
      const promotionOptions = [
        { symbol: color === 'white' ? pieces.white.queen : pieces.black.queen, name: 'Queen' },
        { symbol: color === 'white' ? pieces.white.rook : pieces.black.rook, name: 'Rook' },
        { symbol: color === 'white' ? pieces.white.bishop : pieces.black.bishop, name: 'Bishop' },
        { symbol: color === 'white' ? pieces.white.knight : pieces.black.knight, name: 'Knight' }
      ];
      
      promotionOptions.forEach(option => {
        const pieceEl = document.createElement('div');
        pieceEl.className = `promotion-piece ${color}`;
        pieceEl.innerHTML = option.symbol;
        pieceEl.title = option.name;
        pieceEl.addEventListener('click', () => {
          playSelectSound();
          completePromotion(option.symbol);
        });
        promotionPieces.appendChild(pieceEl);
      });
      
      promotionModal.style.display = 'flex';
      playPromotionSound();
    }

    // Complete the promotion process
    function completePromotion(pieceSymbol) {
      if (!pendingPromotion) return;
      
      const { color, square } = pendingPromotion;
      
      square.innerHTML = '';
      const newPiece = document.createElement('span');
      newPiece.textContent = pieceSymbol;
      newPiece.classList.add(color === 'white' ? 'piece-white' : 'piece-black');
      square.appendChild(newPiece);
      
      promotionModal.style.display = 'none';
      pendingPromotion = null;
      
      playMoveSound();
      
      turn = turn === "white" ? "black" : "white";
      turnDisplay.textContent = turn.charAt(0).toUpperCase() + turn.slice(1);
      turnDisplay.style.color = turn === "white" ? "#fff" : "#00aaff";
      
      updateGameStatus();
      
      if (gameMode === "pvc" && turn === "black" && !gameOver) {
        setTimeout(makeComputerMove, 800);
      }
    }

    // Build board
    function buildBoard() {
      const squares = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const square = document.createElement("div");
          square.classList.add("square", (i + j) % 2 === 0 ? "sq-light" : "sq-dark");
          square.dataset.row = i;
          square.dataset.col = j;

          const piece = startingBoard[i][j];
          if (piece) {
            const span = document.createElement("span");
            span.textContent = piece;
            span.classList.add(getPieceColor(piece) === "white" ? "piece-white" : "piece-black");
            square.appendChild(span);
          }

          board.appendChild(square);
          squares.push(square);
        }
      }
      initializePawnFirstMove();
    }

    buildBoard();

    function getSquare(row, col) {
      return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
    }

    function getPieceAt(row, col) {
      const square = getSquare(row, col);
      const pieceEl = square ? square.querySelector("span") : null;
      return pieceEl ? pieceEl.textContent : "";
    }

    // Enhanced Computer AI with difficulty levels
    function makeComputerMove() {
      if (gameOver || turn !== "black" || pendingPromotion) return;
      
      const possibleMoves = [];
      const isInCheck = isKingInCheck("black");
      
      for (let fromRow = 0; fromRow < 8; fromRow++) {
        for (let fromCol = 0; fromCol < 8; fromCol++) {
          const piece = getPieceAt(fromRow, fromCol);
          if (piece && getPieceColor(piece) === "black") {
            for (let toRow = 0; toRow < 8; toRow++) {
              for (let toCol = 0; toCol < 8; toCol++) {
                if (fromRow === toRow && fromCol === toCol) continue;
                
                const pieceType = getPieceType(piece);
                let isValid = false;
                let moveType = "move";
                
                if (pieceType === "pawn") {
                  const moveResult = isValidPawnMove(fromRow, fromCol, toRow, toCol, "black");
                  isValid = moveResult.valid;
                  moveType = moveResult.type;
                } else if (pieceType === "knight") {
                  const moveResult = isValidKnightMove(fromRow, fromCol, toRow, toCol, "black");
                  isValid = moveResult.valid;
                  moveType = moveResult.type;
                } else if (pieceType === "bishop") {
                  const moveResult = isValidBishopMove(fromRow, fromCol, toRow, toCol, "black");
                  isValid = moveResult.valid;
                  moveType = moveResult.type;
                } else if (pieceType === "rook") {
                  const moveResult = isValidRookMove(fromRow, fromCol, toRow, toCol, "black");
                  isValid = moveResult.valid;
                  moveType = moveResult.type;
                } else if (pieceType === "queen") {
                  const moveResult = isValidQueenMove(fromRow, fromCol, toRow, toCol, "black");
                  isValid = moveResult.valid;
                  moveType = moveResult.type;
                } else if (pieceType === "king") {
                  const rowDiff = Math.abs(toRow - fromRow);
                  const colDiff = Math.abs(toCol - fromCol);
                  if (rowDiff <= 1 && colDiff <= 1) {
                    isValid = true;
                    moveType = getPieceAt(toRow, toCol) ? "capture" : "move";
                  }
                }
                
                const targetPiece = getPieceAt(toRow, toCol);
                if (isValid && targetPiece && getPieceColor(targetPiece) === "black") {
                  isValid = false;
                }
                
                // If in check, only allow moves that save the king
                if (isValid && isInCheck) {
                  if (!moveGetsOutOfCheck(fromRow, fromCol, toRow, toCol, "black")) {
                    isValid = false;
                  }
                }
                
                if (isValid) {
                  let score = 0;
                  
                  // Difficulty-based scoring
                  if (difficulty === "easy") {
                    // Easy: Random moves with basic captures
                    score = Math.random() * 100;
                    if (moveType === "capture") score += getPieceValue(targetPiece);
                    if (isInCheck) score += 50;
                  }
                  else if (difficulty === "medium") {
                    // Medium: Balanced strategy
                    if (moveType === "capture" && targetPiece && getPieceColor(targetPiece) === "white") {
                      score = getPieceValue(targetPiece) * 1.2;
                    }
                    if (isInCheck) score += 100;
                    if (pieceType === "king" && isInCheck) score += 150;
                    if (checkPromotion(piece, toRow)) score += 80;
                    score += Math.random() * 20;
                  }
                  else if (difficulty === "hard") {
                    // Hard: Advanced strategy
                    if (moveType === "capture" && targetPiece && getPieceColor(targetPiece) === "white") {
                      score = getPieceValue(targetPiece) * 1.5;
                      if (getPieceValue(piece) < getPieceValue(targetPiece)) {
                        score += 40;
                      }
                    }
                    if (isInCheck) score += 200;
                    if (pieceType === "king" && isInCheck) score += 300;
                    if (checkPromotion(piece, toRow)) score += 120;
                    if (wouldPutInCheck(toRow, toCol, "white")) score += 80;
                    
                    // Position evaluation
                    if (toRow >= 3 && toRow <= 4 && toCol >= 3 && toCol <= 4) {
                      score += 10;
                    }
                    if (pieceType === "pawn" && toRow > fromRow) {
                      score += 5;
                    }
                    
                    // King safety
                    if (pieceType === "king" && isSquareUnderAttack(toRow, toCol, "black")) {
                      score -= 100;
                    }
                  }
                  
                  possibleMoves.push({
                    fromRow, fromCol, toRow, toCol, piece, score
                  });
                }
              }
            }
          }
        }
      }
      
      if (possibleMoves.length > 0) {
        possibleMoves.sort((a, b) => b.score - a.score);
        
        let topMovesCount;
        if (difficulty === "easy") {
          topMovesCount = Math.min(8, possibleMoves.length);
        } else if (difficulty === "medium") {
          topMovesCount = Math.min(4, possibleMoves.length);
        } else {
          topMovesCount = Math.min(2, possibleMoves.length);
        }
        
        const topMoves = possibleMoves.slice(0, topMovesCount);
        const randomMove = topMoves[Math.floor(Math.random() * topMoves.length)];
        
        setTimeout(() => {
          const { fromRow, fromCol, toRow, toCol, piece } = randomMove;
          const targetPiece = getPieceAt(toRow, toCol);
          
          if (targetPiece && getPieceColor(targetPiece) === "white") {
            addCapturedPiece(targetPiece, "black");
            playCaptureSound();
            
            if (targetPiece === pieces.white.king) {
              checkKingCapture(targetPiece, "black");
            }
          } else {
            playMoveSound();
          }
          
          const fromSquare = getSquare(fromRow, fromCol);
          const toSquare = getSquare(toRow, toCol);
          
          fromSquare.innerHTML = "";
          if (targetPiece && getPieceColor(targetPiece) === "white") toSquare.innerHTML = "";
          const moved = document.createElement("span");
          moved.textContent = piece;
          moved.classList.add("piece-black");
          toSquare.appendChild(moved);
          
          if (getPieceType(piece) === "pawn" && pawnFirstMove[`${fromRow}-${fromCol}`]) {
            delete pawnFirstMove[`${fromRow}-${fromCol}`];
          }
          
          if (checkPromotion(piece, toRow)) {
            showPromotionModal("black", toSquare);
          } else {
            turn = "white";
            turnDisplay.textContent = "White";
            turnDisplay.style.color = "#fff";
            
            updateGameStatus();
          }
        }, difficulty === "hard" ? 1200 : 800);
      }
    }

    // Check if a move would put the opponent in check
    function wouldPutInCheck(row, col, opponentColor) {
      const kingPos = findKingPosition(opponentColor);
      if (!kingPos) return false;
      
      return isSquareUnderAttackByPiece(kingPos.row, kingPos.col, row, col, getPieceType(getPieceAt(row, col)), getPieceColor(getPieceAt(row, col)));
    }

    // Check if a specific piece is attacking a square
    function isSquareUnderAttackByPiece(targetRow, targetCol, pieceRow, pieceCol, pieceType, pieceColor) {
      if (pieceType === "pawn") {
        const direction = pieceColor === "white" ? -1 : 1;
        return (Math.abs(pieceCol - targetCol) === 1 && pieceRow + direction === targetRow);
      } else if (pieceType === "knight") {
        const rowDiff = Math.abs(pieceRow - targetRow);
        const colDiff = Math.abs(pieceCol - targetCol);
        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
      } else if (pieceType === "bishop") {
        const rowDiff = Math.abs(pieceRow - targetRow);
        const colDiff = Math.abs(pieceCol - targetCol);
        if (rowDiff !== colDiff) return false;
        
        const rowDirection = targetRow > pieceRow ? 1 : -1;
        const colDirection = targetCol > pieceCol ? 1 : -1;
        
        for (let i = 1; i < rowDiff; i++) {
          const checkRow = pieceRow + i * rowDirection;
          const checkCol = pieceCol + i * colDirection;
          if (getPieceAt(checkRow, checkCol)) return false;
        }
        return true;
      } else if (pieceType === "rook") {
        const rowDiff = Math.abs(pieceRow - targetRow);
        const colDiff = Math.abs(pieceCol - targetCol);
        if (rowDiff !== 0 && colDiff !== 0) return false;
        
        if (rowDiff === 0) {
          const direction = targetCol > pieceCol ? 1 : -1;
          for (let i = 1; i < colDiff; i++) {
            const checkCol = pieceCol + i * direction;
            if (getPieceAt(pieceRow, checkCol)) return false;
          }
        } else {
          const direction = targetRow > pieceRow ? 1 : -1;
          for (let i = 1; i < rowDiff; i++) {
            const checkRow = pieceRow + i * direction;
            if (getPieceAt(checkRow, pieceCol)) return false;
          }
        }
        return true;
      } else if (pieceType === "queen") {
        const rowDiff = Math.abs(pieceRow - targetRow);
        const colDiff = Math.abs(pieceCol - targetCol);
        if (rowDiff !== 0 && colDiff !== 0 && rowDiff !== colDiff) return false;
        
        if (rowDiff === 0) {
          const direction = targetCol > pieceCol ? 1 : -1;
          for (let i = 1; i < colDiff; i++) {
            const checkCol = pieceCol + i * direction;
            if (getPieceAt(pieceRow, checkCol)) return false;
          }
        } else if (colDiff === 0) {
          const direction = targetRow > pieceRow ? 1 : -1;
          for (let i = 1; i < rowDiff; i++) {
            const checkRow = pieceRow + i * direction;
            if (getPieceAt(checkRow, pieceCol)) return false;
          }
        } else {
          const rowDirection = targetRow > pieceRow ? 1 : -1;
          const colDirection = targetCol > pieceCol ? 1 : -1;
          for (let i = 1; i < rowDiff; i++) {
            const checkRow = pieceRow + i * rowDirection;
            const checkCol = pieceCol + i * colDirection;
            if (getPieceAt(checkRow, checkCol)) return false;
          }
        }
        return true;
      } else if (pieceType === "king") {
        const rowDiff = Math.abs(pieceRow - targetRow);
        const colDiff = Math.abs(pieceCol - targetCol);
        return rowDiff <= 1 && colDiff <= 1;
      }
      return false;
    }

    // All move validation functions
    function isValidPawnMove(fromRow, fromCol, toRow, toCol, pieceColor) {
      const direction = pieceColor === "white" ? -1 : 1;
      const isFirstMove = pawnFirstMove[`${fromRow}-${fromCol}`];
      
      if (toCol === fromCol && toRow === fromRow + direction && !getPieceAt(toRow, toCol)) {
        return { valid: true, type: "move" };
      }
      
      if (isFirstMove && toCol === fromCol && toRow === fromRow + 2 * direction && 
          !getPieceAt(toRow, toCol) && !getPieceAt(fromRow + direction, fromCol)) {
        return { valid: true, type: "move" };
      }
      
      if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction) {
        const targetPiece = getPieceAt(toRow, toCol);
        if (targetPiece && getPieceColor(targetPiece) !== pieceColor) {
          return { valid: true, type: "capture" };
        }
      }
      
      return { valid: false };
    }

    function isValidKnightMove(fromRow, fromCol, toRow, toCol, pieceColor) {
      const rowDiff = Math.abs(toRow - fromRow);
      const colDiff = Math.abs(toCol - fromCol);
      
      if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) {
        return { valid: false };
      }
      
      const targetPiece = getPieceAt(toRow, toCol);
      if (!targetPiece) {
        return { valid: true, type: "move" };
      } else if (getPieceColor(targetPiece) !== pieceColor) {
        return { valid: true, type: "capture" };
      }
      
      return { valid: false };
    }

    function isValidBishopMove(fromRow, fromCol, toRow, toCol, pieceColor) {
      const rowDiff = Math.abs(toRow - fromRow);
      const colDiff = Math.abs(toCol - fromCol);
      
      if (rowDiff !== colDiff) {
        return { valid: false };
      }
      
      const rowDirection = toRow > fromRow ? 1 : -1;
      const colDirection = toCol > fromCol ? 1 : -1;
      
      for (let i = 1; i < rowDiff; i++) {
        const checkRow = fromRow + i * rowDirection;
        const checkCol = fromCol + i * colDirection;
        if (getPieceAt(checkRow, checkCol)) {
          return { valid: false };
        }
      }
      
      const targetPiece = getPieceAt(toRow, toCol);
      if (!targetPiece) {
        return { valid: true, type: "move" };
      } else if (getPieceColor(targetPiece) !== pieceColor) {
        return { valid: true, type: "capture" };
      }
      
      return { valid: false };
    }

    function isValidRookMove(fromRow, fromCol, toRow, toCol, pieceColor) {
      const rowDiff = Math.abs(toRow - fromRow);
      const colDiff = Math.abs(toCol - fromCol);
      
      if (rowDiff !== 0 && colDiff !== 0) {
        return { valid: false };
      }
      
      if (rowDiff === 0) {
        const direction = toCol > fromCol ? 1 : -1;
        for (let i = 1; i < colDiff; i++) {
          const checkCol = fromCol + i * direction;
          if (getPieceAt(fromRow, checkCol)) {
            return { valid: false };
          }
        }
      } else {
        const direction = toRow > fromRow ? 1 : -1;
        for (let i = 1; i < rowDiff; i++) {
          const checkRow = fromRow + i * direction;
          if (getPieceAt(checkRow, fromCol)) {
            return { valid: false };
          }
        }
      }
      
      const targetPiece = getPieceAt(toRow, toCol);
      if (!targetPiece) {
        return { valid: true, type: "move" };
      } else if (getPieceColor(targetPiece) !== pieceColor) {
        return { valid: true, type: "capture" };
      }
      
      return { valid: false };
    }

    function isValidQueenMove(fromRow, fromCol, toRow, toCol, pieceColor) {
      const rowDiff = Math.abs(toRow - fromRow);
      const colDiff = Math.abs(toCol - fromCol);
      
      if (rowDiff !== 0 && colDiff !== 0 && rowDiff !== colDiff) {
        return { valid: false };
      }
      
      if (rowDiff === 0) {
        const direction = toCol > fromCol ? 1 : -1;
        for (let i = 1; i < colDiff; i++) {
          const checkCol = fromCol + i * direction;
          if (getPieceAt(fromRow, checkCol)) {
            return { valid: false };
          }
        }
      } else if (colDiff === 0) {
        const direction = toRow > fromRow ? 1 : -1;
        for (let i = 1; i < rowDiff; i++) {
          const checkRow = fromRow + i * direction;
          if (getPieceAt(checkRow, fromCol)) {
            return { valid: false };
          }
        }
      } else {
        const rowDirection = toRow > fromRow ? 1 : -1;
        const colDirection = toCol > fromCol ? 1 : -1;
        
        for (let i = 1; i < rowDiff; i++) {
          const checkRow = fromRow + i * rowDirection;
          const checkCol = fromCol + i * colDirection;
          if (getPieceAt(checkRow, checkCol)) {
            return { valid: false };
          }
        }
      }
      
      const targetPiece = getPieceAt(toRow, toCol);
      if (!targetPiece) {
        return { valid: true, type: "move" };
      } else if (getPieceColor(targetPiece) !== pieceColor) {
        return { valid: true, type: "capture" };
      }
      
      return { valid: false };
    }

    function isSquareUnderAttack(row, col, defendingColor) {
      const attackingColor = defendingColor === "white" ? "black" : "white";
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = getPieceAt(i, j);
          if (piece && getPieceColor(piece) === attackingColor) {
            const pieceType = getPieceType(piece);
            
            if (pieceType === "pawn") {
              const direction = attackingColor === "white" ? -1 : 1;
              if (Math.abs(j - col) === 1 && i + direction === row) {
                return true;
              }
            } else if (pieceType === "knight") {
              const rowDiff = Math.abs(i - row);
              const colDiff = Math.abs(j - col);
              if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {
                return true;
              }
            } else if (pieceType === "bishop") {
              const rowDiff = Math.abs(i - row);
              const colDiff = Math.abs(j - col);
              if (rowDiff === colDiff) {
                const rowDirection = row > i ? 1 : -1;
                const colDirection = col > j ? 1 : -1;
                let pathClear = true;
                
                for (let k = 1; k < rowDiff; k++) {
                  const checkRow = i + k * rowDirection;
                  const checkCol = j + k * colDirection;
                  if (getPieceAt(checkRow, checkCol)) {
                    pathClear = false;
                    break;
                  }
                }
                
                if (pathClear) return true;
              }
            } else if (pieceType === "rook") {
              const rowDiff = Math.abs(i - row);
              const colDiff = Math.abs(j - col);
              if (rowDiff === 0 || colDiff === 0) {
                let pathClear = true;
                
                if (rowDiff === 0) {
                  const direction = col > j ? 1 : -1;
                  for (let k = 1; k < colDiff; k++) {
                    const checkCol = j + k * direction;
                    if (getPieceAt(i, checkCol)) {
                      pathClear = false;
                      break;
                    }
                  }
                } else {
                  const direction = row > i ? 1 : -1;
                  for (let k = 1; k < rowDiff; k++) {
                    const checkRow = i + k * direction;
                    if (getPieceAt(checkRow, j)) {
                      pathClear = false;
                      break;
                    }
                  }
                }
                
                if (pathClear) return true;
              }
            } else if (pieceType === "queen") {
              const rowDiff = Math.abs(i - row);
              const colDiff = Math.abs(j - col);
              if (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) {
                let pathClear = true;
                
                if (rowDiff === 0) {
                  const direction = col > j ? 1 : -1;
                  for (let k = 1; k < colDiff; k++) {
                    const checkCol = j + k * direction;
                    if (getPieceAt(i, checkCol)) {
                      pathClear = false;
                      break;
                    }
                  }
                } else if (colDiff === 0) {
                  const direction = row > i ? 1 : -1;
                  for (let k = 1; k < rowDiff; k++) {
                    const checkRow = i + k * direction;
                    if (getPieceAt(checkRow, j)) {
                      pathClear = false;
                      break;
                    }
                  }
                } else {
                  const rowDirection = row > i ? 1 : -1;
                  const colDirection = col > j ? 1 : -1;
                  for (let k = 1; k < rowDiff; k++) {
                    const checkRow = i + k * rowDirection;
                    const checkCol = j + k * colDirection;
                    if (getPieceAt(checkRow, checkCol)) {
                      pathClear = false;
                      break;
                    }
                  }
                }
                
                if (pathClear) return true;
              }
            } else if (pieceType === "king") {
              const rowDiff = Math.abs(i - row);
              const colDiff = Math.abs(j - col);
              if (rowDiff <= 1 && colDiff <= 1) {
                return true;
              }
            }
          }
        }
      }
      
      return false;
    }

    function findKingPosition(color) {
      const kingSymbol = color === "white" ? pieces.white.king : pieces.black.king;
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (getPieceAt(i, j) === kingSymbol) {
            return { row: i, col: j };
          }
        }
      }
      return null;
    }

    function isKingInCheck(color) {
      const kingPos = findKingPosition(color);
      if (!kingPos) return false;
      
      return isSquareUnderAttack(kingPos.row, kingPos.col, color);
    }

    // CRITICAL FIX: Check if a move gets the king out of check
    function moveGetsOutOfCheck(fromRow, fromCol, toRow, toCol, color) {
      // Store original state
      const originalFromPiece = getPieceAt(fromRow, fromCol);
      const originalToPiece = getPieceAt(toRow, toCol);
      
      // Temporarily make the move
      const fromSquare = getSquare(fromRow, fromCol);
      const toSquare = getSquare(toRow, toCol);
      
      // Remove piece from original position
      fromSquare.innerHTML = "";
      
      // Place piece in new position
      toSquare.innerHTML = "";
      const tempPiece = document.createElement("span");
      tempPiece.textContent = originalFromPiece;
      tempPiece.classList.add(color === "white" ? "piece-white" : "piece-black");
      toSquare.appendChild(tempPiece);
      
      // Check if king is still in check
      const stillInCheck = isKingInCheck(color);
      
      // Restore original state
      fromSquare.innerHTML = "";
      const fromPiece = document.createElement("span");
      fromPiece.textContent = originalFromPiece;
      fromPiece.classList.add(color === "white" ? "piece-white" : "piece-black");
      fromSquare.appendChild(fromPiece);
      
      toSquare.innerHTML = "";
      if (originalToPiece) {
        const toPiece = document.createElement("span");
        toPiece.textContent = originalToPiece;
        toPiece.classList.add(getPieceColor(originalToPiece) === "white" ? "piece-white" : "piece-black");
        toSquare.appendChild(toPiece);
      }
      
      return !stillInCheck;
    }

    function hasAnyValidMove(color) {
      for (let fromRow = 0; fromRow < 8; fromRow++) {
        for (let fromCol = 0; fromCol < 8; fromCol++) {
          const piece = getPieceAt(fromRow, fromCol);
          if (piece && getPieceColor(piece) === color) {
            for (let toRow = 0; toRow < 8; toRow++) {
              for (let toCol = 0; toCol < 8; toCol++) {
                if (fromRow === toRow && fromCol === toCol) continue;
                
                const pieceType = getPieceType(piece);
                let isValid = false;
                
                if (pieceType === "pawn") {
                  const moveResult = isValidPawnMove(fromRow, fromCol, toRow, toCol, color);
                  isValid = moveResult.valid;
                } else if (pieceType === "knight") {
                  const moveResult = isValidKnightMove(fromRow, fromCol, toRow, toCol, color);
                  isValid = moveResult.valid;
                } else if (pieceType === "bishop") {
                  const moveResult = isValidBishopMove(fromRow, fromCol, toRow, toCol, color);
                  isValid = moveResult.valid;
                } else if (pieceType === "rook") {
                  const moveResult = isValidRookMove(fromRow, fromCol, toRow, toCol, color);
                  isValid = moveResult.valid;
                } else if (pieceType === "queen") {
                  const moveResult = isValidQueenMove(fromRow, fromCol, toRow, toCol, color);
                  isValid = moveResult.valid;
                } else if (pieceType === "king") {
                  const rowDiff = Math.abs(toRow - fromRow);
                  const colDiff = Math.abs(toCol - fromCol);
                  if (rowDiff <= 1 && colDiff <= 1) {
                    isValid = true;
                  }
                }
                
                // Check if this move gets out of check (if in check)
                if (isValid) {
                  const targetPiece = getPieceAt(toRow, toCol);
                  if (targetPiece && getPieceColor(targetPiece) === color) {
                    isValid = false; // Can't capture own pieces
                  } else if (isKingInCheck(color)) {
                    // When in check, only allow moves that save the king
                    if (moveGetsOutOfCheck(fromRow, fromCol, toRow, toCol, color)) {
                      return true;
                    }
                  } else {
                    // When not in check, any valid move is fine
                    return true;
                  }
                }
              }
            }
          }
        }
      }
      
      return false;
    }

    function checkKingCapture(targetPiece, selectedColor) {
      if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
        const capturedKingColor = getPieceColor(targetPiece);
        const winnerColor = capturedKingColor === "white" ? "Black" : "White";
        
        gameOver = true;
        showGameOverMessage(winnerColor);
        playWinSound();
        return true;
      }
      return false;
    }

    function updateGameStatus() {
      gameStatus.textContent = "";
      gameStatus.className = "game-status";
      
      document.querySelectorAll('.king-in-check').forEach(el => {
        el.classList.remove('king-in-check');
      });
      
      if (gameOver) return;
      
      const currentKingColor = turn;
      
      if (isKingInCheck(currentKingColor)) {
        const kingPos = findKingPosition(currentKingColor);
        if (kingPos) {
          const kingSquare = getSquare(kingPos.row, kingPos.col);
          const kingPiece = kingSquare.querySelector('span');
          kingPiece.classList.add('king-in-check');
        }
        
        if (!hasAnyValidMove(currentKingColor)) {
          const winnerColor = currentKingColor === "white" ? "Black" : "White";
          gameOver = true;
          showGameOverMessage(winnerColor);
          playCheckmateSound();
          return;
        } else {
          gameStatus.textContent = "CHECK! - Save Your King!";
          gameStatus.classList.add("check-status");
          playCheckSound();
        }
      }
    }

    function showValidMoves(row, col, piece) {
      document.querySelectorAll(".valid-move, .capture-move, .king-capture-move").forEach(el => {
        el.classList.remove("valid-move", "capture-move", "king-capture-move");
      });

      const pieceType = getPieceType(piece);
      const pieceColor = getPieceColor(piece);
      const isInCheck = isKingInCheck(pieceColor);

      if (pieceType === "pawn") {
        const direction = pieceColor === "white" ? -1 : 1;
        const isFirstMove = pawnFirstMove[`${row}-${col}`];
        
        if (row + direction >= 0 && row + direction < 8 && !getPieceAt(row + direction, col)) {
          if (!isInCheck || moveGetsOutOfCheck(row, col, row + direction, col, pieceColor)) {
            getSquare(row + direction, col).classList.add("valid-move");
          }
        }
        
        if (isFirstMove && row + 2 * direction >= 0 && row + 2 * direction < 8 && 
            !getPieceAt(row + 2 * direction, col) && !getPieceAt(row + direction, col)) {
          if (!isInCheck || moveGetsOutOfCheck(row, col, row + 2 * direction, col, pieceColor)) {
            getSquare(row + 2 * direction, col).classList.add("valid-move");
          }
        }
        
        for (let offset of [-1, 1]) {
          if (col + offset >= 0 && col + offset < 8 && row + direction >= 0 && row + direction < 8) {
            const targetPiece = getPieceAt(row + direction, col + offset);
            if (targetPiece) {
              if (getPieceColor(targetPiece) !== pieceColor) {
                if (!isInCheck || moveGetsOutOfCheck(row, col, row + direction, col + offset, pieceColor)) {
                  if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
                    getSquare(row + direction, col + offset).classList.add("king-capture-move");
                  } else {
                    getSquare(row + direction, col + offset).classList.add("capture-move");
                  }
                }
              }
            }
          }
        }
      } else if (pieceType === "knight") {
        const knightMoves = [
          {row: -2, col: -1}, {row: -2, col: 1},
          {row: -1, col: -2}, {row: -1, col: 2},
          {row: 1, col: -2}, {row: 1, col: 2},
          {row: 2, col: -1}, {row: 2, col: 1}
        ];
        
        for (let move of knightMoves) {
          const newRow = row + move.row;
          const newCol = col + move.col;
          
          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetPiece = getPieceAt(newRow, newCol);
            if (!targetPiece) {
              if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                getSquare(newRow, newCol).classList.add("valid-move");
              }
            } else if (getPieceColor(targetPiece) !== pieceColor) {
              if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
                  getSquare(newRow, newCol).classList.add("king-capture-move");
                } else {
                  getSquare(newRow, newCol).classList.add("capture-move");
                }
              }
            }
          }
        }
      } else if (pieceType === "bishop") {
        const directions = [
          {row: -1, col: -1}, {row: -1, col: 1},
          {row: 1, col: -1}, {row: 1, col: 1}
        ];
        
        for (let direction of directions) {
          for (let distance = 1; distance < 8; distance++) {
            const newRow = row + direction.row * distance;
            const newCol = col + direction.col * distance;
            
            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) {
              break;
            }
            
            const targetPiece = getPieceAt(newRow, newCol);
            if (!targetPiece) {
              if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                getSquare(newRow, newCol).classList.add("valid-move");
              }
            } else {
              if (getPieceColor(targetPiece) !== pieceColor) {
                if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                  if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
                    getSquare(newRow, newCol).classList.add("king-capture-move");
                  } else {
                    getSquare(newRow, newCol).classList.add("capture-move");
                  }
                }
              }
              break;
            }
          }
        }
      } else if (pieceType === "rook") {
        const directions = [
          {row: -1, col: 0}, {row: 1, col: 0},
          {row: 0, col: -1}, {row: 0, col: 1}
        ];
        
        for (let direction of directions) {
          for (let distance = 1; distance < 8; distance++) {
            const newRow = row + direction.row * distance;
            const newCol = col + direction.col * distance;
            
            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) {
              break;
            }
            
            const targetPiece = getPieceAt(newRow, newCol);
            if (!targetPiece) {
              if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                getSquare(newRow, newCol).classList.add("valid-move");
              }
            } else {
              if (getPieceColor(targetPiece) !== pieceColor) {
                if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                  if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
                    getSquare(newRow, newCol).classList.add("king-capture-move");
                  } else {
                    getSquare(newRow, newCol).classList.add("capture-move");
                  }
                }
              }
              break;
            }
          }
        }
      } else if (pieceType === "queen") {
        const directions = [
          {row: -1, col: 0}, {row: 1, col: 0},
          {row: 0, col: -1}, {row: 0, col: 1},
          {row: -1, col: -1}, {row: -1, col: 1},
          {row: 1, col: -1}, {row: 1, col: 1}
        ];
        
        for (let direction of directions) {
          for (let distance = 1; distance < 8; distance++) {
            const newRow = row + direction.row * distance;
            const newCol = col + direction.col * distance;
            
            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) {
              break;
            }
            
            const targetPiece = getPieceAt(newRow, newCol);
            if (!targetPiece) {
              if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                getSquare(newRow, newCol).classList.add("valid-move");
              }
            } else {
              if (getPieceColor(targetPiece) !== pieceColor) {
                if (!isInCheck || moveGetsOutOfCheck(row, col, newRow, newCol, pieceColor)) {
                  if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
                    getSquare(newRow, newCol).classList.add("king-capture-move");
                  } else {
                    getSquare(newRow, newCol).classList.add("capture-move");
                  }
                }
              }
              break;
            }
          }
        }
      } else {
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (i === row && j === col) continue;
            
            const rowDiff = Math.abs(i - row);
            const colDiff = Math.abs(j - col);
            
            if (rowDiff <= 1 && colDiff <= 1) {
              const targetPiece = getPieceAt(i, j);
              if (!targetPiece) {
                if (!isInCheck || moveGetsOutOfCheck(row, col, i, j, pieceColor)) {
                  getSquare(i, j).classList.add("valid-move");
                }
              } else if (getPieceColor(targetPiece) !== pieceColor) {
                if (!isInCheck || moveGetsOutOfCheck(row, col, i, j, pieceColor)) {
                  if (targetPiece === pieces.white.king || targetPiece === pieces.black.king) {
                    getSquare(i, j).classList.add("king-capture-move");
                  } else {
                    getSquare(i, j).classList.add("capture-move");
                  }
                }
              }
            }
          }
        }
      }
    }

    // Handle moves
    board.addEventListener("click", (e) => {
      if (gameOver || pendingPromotion) return;
      
      if (gameMode === "pvc" && turn === "black") return;
      
      const target = e.target.closest(".square");
      if (!target) return;

      const row = parseInt(target.dataset.row);
      const col = parseInt(target.dataset.col);
      const pieceEl = target.querySelector("span");
      const piece = pieceEl ? pieceEl.textContent : "";
      const color = getPieceColor(piece);

      // Check if king is in check
      const isInCheck = isKingInCheck(turn);
      
      if (selectedSquare && (target.classList.contains("valid-move") || target.classList.contains("capture-move") || target.classList.contains("king-capture-move"))) {
        const selectedRow = parseInt(selectedSquare.dataset.row);
        const selectedCol = parseInt(selectedSquare.dataset.col);
        const selectedPieceEl = selectedSquare.querySelector("span");
        const selectedPiece = selectedPieceEl.textContent;
        const selectedColor = getPieceColor(selectedPiece);
        
        // If in check, verify this move gets out of check
        if (isInCheck && !moveGetsOutOfCheck(selectedRow, selectedCol, row, col, selectedColor)) {
          playErrorSound();
          return;
        }
        
        const pieceType = getPieceType(selectedPiece);
        let isValid = false;
        let moveType = "move";
        
        if (pieceType === "pawn") {
          const moveResult = isValidPawnMove(selectedRow, selectedCol, row, col, selectedColor);
          isValid = moveResult.valid;
          moveType = moveResult.type;
        } else if (pieceType === "knight") {
          const moveResult = isValidKnightMove(selectedRow, selectedCol, row, col, selectedColor);
          isValid = moveResult.valid;
          moveType = moveResult.type;
        } else if (pieceType === "bishop") {
          const moveResult = isValidBishopMove(selectedRow, selectedCol, row, col, selectedColor);
          isValid = moveResult.valid;
          moveType = moveResult.type;
        } else if (pieceType === "rook") {
          const moveResult = isValidRookMove(selectedRow, selectedCol, row, col, selectedColor);
          isValid = moveResult.valid;
          moveType = moveResult.type;
        } else if (pieceType === "queen") {
          const moveResult = isValidQueenMove(selectedRow, selectedCol, row, col, selectedColor);
          isValid = moveResult.valid;
          moveType = moveResult.type;
        } else {
          const rowDiff = Math.abs(row - selectedRow);
          const colDiff = Math.abs(col - selectedCol);
          
          if (rowDiff <= 1 && colDiff <= 1) {
            const targetPiece = getPieceAt(row, col);
            isValid = true;
            moveType = targetPiece ? "capture" : "move";
          } else {
            isValid = false;
          }
        }
        
        if (isValid) {
          if (piece && moveType === "capture") {
            addCapturedPiece(piece, selectedColor);
            playCaptureSound();
            
            if (piece === pieces.white.king || piece === pieces.black.king) {
              checkKingCapture(piece, selectedColor);
            }
          } else {
            playMoveSound();
          }
          
          selectedPieceEl.classList.remove("selected");
          
          selectedSquare.innerHTML = "";
          if (pieceEl && moveType === "capture") target.innerHTML = "";
          const moved = document.createElement("span");
          moved.textContent = selectedPiece;
          moved.classList.add(selectedColor === "white" ? "piece-white" : "piece-black");
          target.appendChild(moved);
          
          if (pieceType === "pawn" && pawnFirstMove[`${selectedRow}-${selectedCol}`]) {
            delete pawnFirstMove[`${selectedRow}-${selectedCol}`];
          }
          
          document.querySelectorAll(".valid-move, .capture-move, .king-capture-move").forEach(el => {
            el.classList.remove("valid-move", "capture-move", "king-capture-move");
          });
          
          selectedSquare = null;
          
          if (checkPromotion(selectedPiece, row)) {
            showPromotionModal(selectedColor, target);
          } else {
            if (!gameOver) {
              turn = turn === "white" ? "black" : "white";
              turnDisplay.textContent = turn.charAt(0).toUpperCase() + turn.slice(1);
              turnDisplay.style.color = turn === "white" ? "#fff" : "#00aaff";
              
              updateGameStatus();
              
              if (gameMode === "pvc" && turn === "black" && !gameOver) {
                setTimeout(makeComputerMove, 800);
              }
            }
          }
        } else {
          playErrorSound();
        }
        return;
      }

      if (!selectedSquare) {
        if (!piece || color !== turn) {
          if (piece && color !== turn) {
            playErrorSound();
          }
          return;
        }
        
        selectedSquare = target;
        pieceEl.classList.add("selected");
        showValidMoves(row, col, piece);
        playSelectSound();
        return;
      }

      if (selectedSquare === target) {
        selectedSquare.querySelector("span").classList.remove("selected");
        document.querySelectorAll(".valid-move, .capture-move, .king-capture-move").forEach(el => {
          el.classList.remove("valid-move", "capture-move", "king-capture-move");
        });
        selectedSquare = null;
        return;
      }

      if (piece && color === turn) {
        selectedSquare.querySelector("span").classList.remove("selected");
        document.querySelectorAll(".valid-move, .capture-move, .king-capture-move").forEach(el => {
          el.classList.remove("valid-move", "capture-move", "king-capture-move");
        });
        selectedSquare = target;
        pieceEl.classList.add("selected");
        showValidMoves(row, col, piece);
        playSelectSound();
        return;
      }
    });

    updateGameStatus();
  </script>
</body>
</html>